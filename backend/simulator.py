import os
import time
import json
import random
from web3 import Web3
from dotenv import load_dotenv

# Load environment variables from the .env file.
load_dotenv()

# --- Configuration ---
# Replace with the RPC URL of your local Hardhat network or a testnet.
# We'll use the Hardhat default here.
RPC_URL = os.getenv("RPC_URL", "http://127.0.0.1:8545")

# The private key of the account that will sign the transactions.
# This should be the owner account from your Hardhat network.
PRIVATE_KEY = os.getenv("PRIVATE_KEY")

# The address of your deployed AccessLog smart contract.
CONTRACT_ADDRESS = os.getenv("CONTRACT_ADDRESS")

# The path to the compiled contract ABI. This is generated by Hardhat.
# Make sure you compile your contract first by running `npx hardhat compile`.
CONTRACT_ABI_PATH = "./artifacts/contracts/AccessLog.sol/AccessLog.json"

# List of possible locations and event types to simulate.
LOCATIONS = ["Main Entrance", "Server Room", "Warehouse", "Loading Dock"]
EVENT_TYPES = ["Entry", "Exit", "Unusual Activity", "Entry"] # We weight Entry more heavily for realism

# --- Main Script ---
def get_contract():
    """
    Connects to the blockchain, loads the contract ABI, and returns a contract instance.
    """
    try:
        w3 = Web3(Web3.HTTPProvider(RPC_URL))
        if not w3.isConnected():
            raise Exception("Failed to connect to the blockchain.")

        # Load the contract ABI from the Hardhat artifacts.
        with open(CONTRACT_ABI_PATH, 'r') as f:
            contract_json = json.load(f)
        abi = contract_json['abi']
        
        contract = w3.eth.contract(address=w3.toChecksumAddress(CONTRACT_ADDRESS), abi=abi)
        return w3, contract
    except Exception as e:
        print(f"Error getting contract instance: {e}")
        return None, None

def simulate_and_record_event():
    """
    Simulates a security event and sends a transaction to the smart contract.
    """
    w3, contract = get_contract()
    if not w3 or not contract:
        return

    # Get the sender's account from the private key.
    account = w3.eth.account.from_key(PRIVATE_KEY)
    w3.eth.default_account = account.address
    
    print(f"\nConnected to network with address: {account.address}")
    
    # Simulate a new event.
    location = random.choice(LOCATIONS)
    event_type = random.choice(EVENT_TYPES)
    # Use a random hash to simulate a unique identifier for the event/person.
    data_hash = "0x" + os.urandom(10).hex() 

    print(f"Simulating a '{event_type}' event at '{location}'...")

    try:
        # Build the transaction to call the `recordEvent` function.
        nonce = w3.eth.get_transaction_count(account.address)
        tx = contract.functions.recordEvent(location, event_type, data_hash).build_transaction({
            'from': account.address,
            'nonce': nonce,
            'gasPrice': w3.toWei('20', 'gwei') # Set a reasonable gas price
        })

        # Sign the transaction with the private key.
        signed_tx = w3.eth.account.sign_transaction(tx, private_key=PRIVATE_KEY)
        
        # Send the signed transaction.
        tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        
        print(f"Transaction sent: {w3.toHex(tx_hash)}")
        print("Waiting for transaction to be mined...")
        
        # Wait for the transaction receipt to confirm it's on the blockchain.
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
        print(f"Transaction confirmed in block {tx_receipt['blockNumber']}")
        print(f"Event recorded: [Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}, Location: {location}, Type: {event_type}, Hash: {data_hash}]")

    except Exception as e:
        print(f"Error sending transaction: {e}")

if __name__ == "__main__":
    print("Sentinel-3 IoT Simulator started.")
    print("Press Ctrl+C to stop.")
    
    # Run a loop to simulate events every few seconds.
    while True:
        try:
            simulate_and_record_event()
            # Wait a random amount of time between 5 and 15 seconds.
            time.sleep(random.randint(5, 15))
        except KeyboardInterrupt:
            print("\nSimulator stopped.")
            break
